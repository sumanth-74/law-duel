import OpenAI from "openai";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

const MBE_SCHEMA = {
  name: "MBEItem",
  schema: {
    type: "object",
    properties: {
      id: { type: "string" },
      subject: { type: "string" },
      topic: { type: "string" },
      subtopic: { type: "string" },
      stem: { type: "string" },
      choices: { type: "array", items: { type: "string" }, minItems: 4, maxItems: 4 },
      correctIndex: { type: "integer", minimum: 0, maximum: 3 },
      optionRationales: { 
        type: "object",
        properties: {
          "0": { type: "string" },
          "1": { type: "string" },
          "2": { type: "string" },
          "3": { type: "string" }
        },
        required: ["0", "1", "2", "3"],
        additionalProperties: false
      },
      explanationLong: { type: "string" },
      ruleRefs: { type: "array", items: { type: "string" } },
      difficultySeed: { type: "string", enum: ["easy", "medium", "hard"] },
      timeLimitSec: { type: "integer" },
      tags: { type: "array", items: { type: "string" } },
      license: { type: "string" },
      status: { type: "string" },
      authorNote: { type: "string" }
    },
    required: ["subject", "topic", "stem", "choices", "correctIndex", "optionRationales",
               "explanationLong", "ruleRefs", "difficultySeed", "license", "status"],
    additionalProperties: false
  },
  strict: true
};

export async function generateMBEItem({ subject, topic, subtopic, rule }) {
  const ruleText = rule ? ` focusing on ${rule}` : '';
  const subtopicText = subtopic ? `/${subtopic}` : '';
  
  const prompt = `
Write an original MBE-style multiple-choice question for ${subject} on ${topic}${subtopicText}${ruleText}.
Single best answer, exactly 4 options (A–D). 120–180 word fact pattern.
Test: ${rule || topic} under national law (FRE/FRCP/UCC Art. 2/federal constitutional law as relevant).
Include rationales for each option (why each is right/wrong) and a 3–6 sentence explanation. 
No "all/none of the above."
Make this INCREDIBLY DIFFICULT - upper 10% difficulty for bar exam takers.
Set id = unique string, difficultySeed = "hard", timeLimitSec = 90, license = "educational", status = "active", authorNote = "Generated for Law Duel competitive play".
Output ONLY JSON matching our schema.`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: "You are an expert legal educator creating high-quality MBE questions. Generate professional, challenging questions with detailed explanations. Output only valid JSON."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      response_format: { 
        type: "json_object"
      },
      temperature: 0.7,
    });

    const jsonText = response.choices[0].message.content;
    if (!jsonText) {
      throw new Error('No response content from OpenAI');
    }

    const rawResponse = JSON.parse(jsonText);
    
    // Extract the actual question data - it might be nested under "question" or at root level
    const item = rawResponse.question || rawResponse;
    
    console.log('OpenAI response structure:', Object.keys(rawResponse));
    console.log('Extracted item structure:', Object.keys(item));
    
    // Map OpenAI response fields to our expected format
    let choices = [];
    if (item.options && Array.isArray(item.options)) {
      choices = item.options.map(opt => typeof opt === 'string' ? opt : opt.text || opt.option || String(opt));
    } else if (item.choices) {
      choices = item.choices;
    }

    const mappedItem = {
      stem: item.stem || item.factPattern || item.question || "Legal question generated by OpenAI",
      choices: choices,
      correctIndex: typeof item.correctIndex === 'number' ? item.correctIndex : 
                    (item.correctAnswer ? ['A', 'B', 'C', 'D'].indexOf(item.correctAnswer) : 0),
      explanation: item.explanation || (Array.isArray(item.rationales) ? item.rationales.join(' ') : item.rationales) || "Legal analysis provided.",
      subject: subject,
      id: `openai_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    };

    // Validate that we got all required fields
    if (!mappedItem.stem || !mappedItem.choices || mappedItem.choices.length !== 4) {
      console.log('❌ MBE validation failed:', { 
        hasStem: !!mappedItem.stem, 
        hasChoices: !!mappedItem.choices,
        choicesCount: mappedItem.choices?.length,
        originalKeys: Object.keys(item)
      });
      throw new Error('Invalid MBE item structure');
    }

    console.log('✅ MBE validation passed');
    return mappedItem;
    
  } catch (error) {
    console.error('Failed to generate MBE item:', error);
    
    // Handle specific OpenAI errors
    if (error.status === 429 || error.message.includes('quota')) {
      throw new Error('QUOTA_EXCEEDED');
    }
    
    if (error.status === 401) {
      throw new Error('INVALID_API_KEY');
    }
    
    throw new Error('Failed to generate MBE question');
  }
}

// Predefined daily topics for rotation
export const DAILY_TOPICS = [
  { subject: "Evidence", topic: "Hearsay", subtopic: "801(d)(1)(C)", rule: "prior identification non-hearsay" },
  { subject: "Constitutional Law", topic: "Due Process", subtopic: "Procedural", rule: "Mathews v. Eldridge balancing test" },
  { subject: "Contracts", topic: "Statute of Frauds", subtopic: "Performance", rule: "part performance doctrine" },
  { subject: "Torts", topic: "Negligence", subtopic: "Duty", rule: "special relationship liability" },
  { subject: "Criminal Law", topic: "Fourth Amendment", subtopic: "Searches", rule: "reasonable expectation of privacy" },
  { subject: "Property", topic: "Estates", subtopic: "Rule Against Perpetuities", rule: "measuring lives analysis" },
  { subject: "Civil Procedure", topic: "Personal Jurisdiction", subtopic: "Specific", rule: "purposeful availment standard" }
];

export function getDailyTopic(dayOfYear) {
  return DAILY_TOPICS[dayOfYear % DAILY_TOPICS.length];
}