0) One-time setup (Replit)
Add your key in Secrets as OPENAI_API_KEY.

Install deps:

bash
Copy
Edit
npm i openai express ajv crypto
We’ll use Responses API + Structured Outputs to force clean JSON. 
OpenAI Platform
+1

1) generator.js — call OpenAI + return a fresh MBE item
js
Copy
Edit
// generator.js
import OpenAI from "openai";
import crypto from "crypto";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// Minimal taxonomy for randomness (expand anytime)
const SUBJECTS = {
  "Civ Pro": ["Subject Matter Jurisdiction", "Personal Jurisdiction", "Erie", "Preclusion"],
  "Con Law": ["Speech", "Equal Protection", "Due Process", "Commerce Clause"],
  "Contracts": ["Offer/Acceptance", "Consideration", "UCC §2—Risk of Loss", "Parol Evidence"],
  "Crim": ["Homicide", "Accomplice/Pinkerton", "Fourth Amendment", "Miranda"],
  "Evidence": ["Relevance 401/403", "Character 404/405", "Hearsay 801–807", "Impeachment 613"],
  "Property": ["Future Interests & RAP", "Recording Acts", "Landlord–Tenant", "Mortgages"],
  "Torts": ["Negligence", "Strict Liability", "Defamation", "Products Liability"]
};

// Pick random subject/topic unless caller requests one
function randomSpec(preferredSubject) {
  const subjects = preferredSubject && SUBJECTS[preferredSubject] ? [preferredSubject] : Object.keys(SUBJECTS);
  const subject = subjects[Math.floor(Math.random() * subjects.length)];
  const topicList = SUBJECTS[subject];
  const topic = topicList[Math.floor(Math.random() * topicList.length)];
  // Optional: add a subtopic/rule hint for better variety
  const ruleHints = {
    "Evidence:Hearsay 801–807": "801(d)(1)(C) prior identification is non-hearsay",
    "Contracts:UCC §2—Risk of Loss": "UCC §2-510: buyer breach & identified goods",
    "Property:Recording Acts": "Race-notice: BFP without notice who records first",
    "Crim:Miranda": "Unwarned statement admissible for impeachment if voluntary"
  };
  const key = `${subject}:${topic}`;
  const rule = ruleHints[key] || `${topic} — test the black-letter rule`;
  return { subject, topic, subtopic: null, rule };
}

const MBE_SCHEMA = {
  name: "MBEItem",
  schema: {
    type: "object",
    properties: {
      id: { type: "string" },
      subject: { type: "string" },
      topic: { type: "string" },
      subtopic: { type: "string" },
      stem: { type: "string" },
      choices: { type: "array", items: { type: "string" }, minItems: 4, maxItems: 4 },
      correctIndex: { type: "integer", minimum: 0, maximum: 3 },
      optionRationales: { type: "object" },
      explanationLong: { type: "string" },
      ruleRefs: { type: "array", items: { type: "string" } },
      difficultySeed: { type: "string", enum: ["easy","medium","hard"] },
      timeLimitSec: { type: "integer" },
      tags: { type: "array", items: { type: "string" } },
      license: { type: "string" },
      status: { type: "string" },
      authorNote: { type: "string" }
    },
    required: ["subject","topic","stem","choices","correctIndex","optionRationales","explanationLong","ruleRefs","difficultySeed","license","status"],
    additionalProperties: false
  },
  strict: true
};

export async function generateMBEItem({ subject }) {
  const spec = randomSpec(subject);
  const prompt = `
Write an original **MBE-style** multiple-choice question for ${spec.subject} on ${spec.topic}.
Single best answer, exactly 4 options (A–D). Fact pattern length: 120–180 words.
Test this rule: ${spec.rule} under national law (FRE/FRCP/UCC Art.2/federal con law as relevant).
Include **rationales for each option** and a **3–6 sentence explanation**. 
No “all/none of the above”. Output ONLY JSON for our schema. Label difficultySeed = easy|medium|hard.`;

  // Call OpenAI Responses API with Structured Outputs → valid JSON every time
  const resp = await openai.responses.create({
    model: "gpt-4o-mini",
    input: prompt,
    response_format: { type: "json_schema", json_schema: MBE_SCHEMA }
  }); // Responses API + structured outputs docs. :contentReference[oaicite:1]{index=1}

  const item = JSON.parse(resp.output_text);
  // Ensure unique id each time
  item.id = item.id || `${spec.subject.slice(0,2).toUpperCase()}-${Date.now()}-${crypto.randomBytes(3).toString("hex")}`;
  item.license = "© Law Duel, original";
  item.status = "draft";
  // Backfill subject/topic (model usually returns them, but ensure)
  item.subject = item.subject || spec.subject;
  item.topic = item.topic || spec.topic;
  return item;
}
2) validate.js — schema validation (reject bad drafts)
js
Copy
Edit
// validate.js
import Ajv from "ajv";
const ajv = new Ajv({ allErrors: true, strict: true });

export const mbeItemSchema = /* same shape as in generator */;
export const validateItem = ajv.compile(mbeItemSchema);

export function basicContentChecks(item) {
  const joined = [...item.choices].join(" ").toLowerCase();
  if (joined.includes("all of the above") || joined.includes("none of the above")) return "Banned phrasing";
  if (!Array.isArray(item.choices) || item.choices.length !== 4) return "Must have exactly 4 choices";
  if (typeof item.correctIndex !== "number" || item.correctIndex < 0 || item.correctIndex > 3) return "Bad correctIndex";
  const stemWords = (item.stem || "").trim().split(/\s+/).length;
  if (stemWords < 120 || stemWords > 200) return "Stem must be ~120–180 words";
  return null;
}
3) routes/generate.js — API to fetch a random fresh question
js
Copy
Edit
// routes/generate.js
import express from "express";
import { generateMBEItem } from "../generator.js";
import { validateItem, basicContentChecks } from "../validate.js";
import { saveItem } from "../db.js"; // implement to store in your DB (or memory for MVP)

const r = express.Router();

/**
 * GET /v1/items/generate-random
 * Optional query: ?subject=Evidence  (otherwise picks a random subject/topic)
 */
r.get("/v1/items/generate-random", async (req, res) => {
  try {
    const subject = req.query.subject; // optional filter from user
    const draft = await generateMBEItem({ subject });

    // Validate + quick content lint
    const ok = validateItem(draft);
    if (!ok) return res.status(422).json({ error: "Invalid schema", details: validateItem.errors });
    const contentErr = basicContentChecks(draft);
    if (contentErr) return res.status(422).json({ error: contentErr });

    // Save (or skip saving if you just want to serve ad hoc)
    await saveItem(draft); // mark as draft/approved per your workflow
    // Return without correctIndex to the client unless it’s an admin call
    const { correctIndex, ...safe } = draft;
    res.json({ item: safe });
  } catch (e) {
    res.status(500).json({ error: e.message || "generation failed" });
  }
});

export default r;
Mount it in your server:

js
Copy
Edit
// server.js
import express from "express";
import genRoutes from "./routes/generate.js";
const app = express();
app.use(express.json());
app.use(genRoutes);
app.listen(process.env.PORT || 3000);
4) How “always random” works here
If the caller doesn’t pass subject, generator.js picks a random subject + topic from your taxonomy each time.

If the caller does pass subject=Evidence, it’ll randomize the topic/rule within Evidence.

Each call hits OpenAI fresh → unique item JSON, forced by the Structured Outputs schema so the format is correct. 
OpenAI Platform

For scale, add:

Rate-limit/backoff so you don’t hit model limits (429); see Rate Limits. 
OpenAI Platform

Batch or queue generations if you’re creating many at once. 
OpenAI Platform

5) Quick client usage
Random subject: GET /v1/items/generate-random

Specific subject: GET /v1/items/generate-random?subject=Contracts

6) Acceptance checks (run these now)
Hitting /v1/items/generate-random twice returns two different items (different id, different stems).

Passing ?subject=Torts yields a Torts item, then another Torts item on the next call, not a repeat.

Returned JSON has choices.length === 4, no “all/none of the above,” and a 120–180-word stem.