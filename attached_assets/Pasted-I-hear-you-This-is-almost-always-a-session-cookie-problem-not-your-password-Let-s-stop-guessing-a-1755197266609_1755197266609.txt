I hear you. This is almost always a session/cookie problem, not your password. Let’s stop guessing and force it to work with one tight checklist + the exact patches to paste to Replit.

5-minute triage: find where it’s breaking

You only need these two facts:

Does /api/auth/login set a cookie?

Does /api/auth/me return 200 with that cookie?

Run this (replace <your-app> with your Replit prod URL, e.g. https://law-duel-savannah41.replit.app):

# 1) Login and capture cookie
curl -i -c jar.txt -H 'Content-Type: application/json' \
  -d '{"username":"debuguser","password":"test123"}' \
  https://<your-app>/api/auth/login

# Expect: HTTP/1.1 200 AND a Set-Cookie: sid=...; Path=/; HttpOnly; SameSite=...

# 2) Use that cookie
curl -i -b jar.txt https://<your-app>/api/auth/me
# Expect: 200 with { ok:true, user:{...} }


If (1) has no Set-Cookie, server cookie config is wrong.

If (1) sets cookie but (2) is 401, session isn’t being saved/read.

If both succeed but the browser still loops, the SPA isn’t sending cookies (credentials:"include") or you’re on a different origin (preview vs prod).

Below is the copy-paste fix that covers all three.

Paste this to Replit: “Fix login loop & make sessions stick”
1) Use one origin in prod (serve the React build from Express)
// server/app.ts
import express from "express";
import session from "express-session";
import path from "path";
import cors from "cors";

const app = express();
const PROD = process.env.NODE_ENV === "production";
app.set("trust proxy", 1);                         // REQUIRED behind Replit proxy

// If you sometimes test cross-origin (preview/dev), list them here:
const ALLOWED = [
  "http://localhost:5173",
  "https://*.replit.dev",
  "https://*.replit.app"
];

// CORS only matters when front & API are different origins
app.use(cors({
  origin: (origin, cb) => {
    if (!origin) return cb(null, true);
    const ok = ALLOWED.some(p => {
      if (p.includes("*")) return new RegExp(p.replace(/\./g,"\\.").replace("*",".*")).test(origin);
      return p === origin;
    });
    cb(null, ok);
  },
  credentials: true
}));

app.use(express.json());

2) Session config (no domain, correct SameSite/secure, before routes)
// server/session.ts (or inline before routes)
import session from "express-session";

const SAME_ORIGIN = true;   // set to false ONLY if your front is on a different origin
app.use(session({
  name: "sid",
  secret: process.env.SESSION_SECRET || "change-me",
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,
    sameSite: SAME_ORIGIN ? "lax" : "none",
    secure: PROD,                   // true on HTTPS (Replit prod)
    maxAge: 30*24*60*60*1000,
    path: "/"                       // DO NOT set "domain"
  }
}));


Order matters: session middleware must be mounted before any /api routes.

(If you’re using a store like connect-pg-simple, import it ESM-style and keep it; otherwise MemoryStore is fine short-term.)

3) Auth routes (regenerate + save; JSON only)
// server/auth.ts
import { Router } from "express";
import bcrypt from "bcrypt";
import { getUserByUsername } from "./db";
const r = Router();

r.post("/login", async (req, res, next) => {
  const { username, password } = req.body || {};
  const user = await getUserByUsername(username);
  if (!user) return res.status(401).json({ ok:false, error:"Invalid" });
  const ok = await bcrypt.compare(password, user.passwordHash);
  if (!ok) return res.status(401).json({ ok:false, error:"Invalid" });

  req.session.regenerate((err) => {
    if (err) return next(err);
    req.session.user = { id: user.id, username: user.username };
    req.session.save((err2) => {
      if (err2) return next(err2);
      res.json({ ok:true, user: req.session.user });
    });
  });
});

r.get("/me", (req, res) => {
  if (!req.session.user) return res.status(401).json({ ok:false });
  res.json({ ok:true, user: req.session.user });
});

r.post("/logout", (req, res) => {
  req.session.destroy(() => {
    res.clearCookie("sid", { path:"/" });
    res.json({ ok:true });
  });
});

export default r;


Mount before anything else:

// server/index.ts
import app from "./app";
import auth from "./auth";
app.use("/api/auth", auth);

4) Serve the SPA from the same origin in prod
if (PROD) {
  const staticDir = path.join(process.cwd(), "client/dist");
  app.use(express.static(staticDir));
  app.get(/^(?!\/api).*/, (_req, res) => res.sendFile(path.join(staticDir, "index.html")));
}

5) Frontend must send cookies on every request

Search and fix all fetch/axios calls.

// client/src/api.ts
export async function api(path: string, opts: RequestInit = {}) {
  const res = await fetch(`/api${path}`, {
    ...opts,
    credentials: "include",                     // ← this is the usual bug
    headers: { "Content-Type": "application/json", ...(opts.headers||{}) }
  });
  return res;
}


Boot flow:

// On app load
const res = await api("/auth/me");
if (res.ok) navigate("/play"); else navigate("/login");

What will break it (so you can spot it fast)

Preview vs Production origin: preview is *.replit.dev, prod is *.replit.app. Cookies from one won’t be sent to the other. Test on one origin (prod) until this is stable.

Cookie domain set: remove it; let host-only cookies work.

SameSite wrong: if cross-origin, you must use "none" and secure:true. If same origin, "lax" is correct.

Session mounted after routes: /auth/me will always be 401.

SPA not sending credentials: any single fetch without credentials:"include" can bounce you.

Go/No-Go (what you should check now)

After logging in on the prod URL, DevTools → Network → /api/auth/login shows Set-Cookie.

A fresh request to /api/auth/me returns 200 and you land on /play.

A full refresh keeps you logged in.

Your friend (another device) logs in on the same prod URL and also lands on /play.

If any of those fail, tell Replit exactly which bullet failed and paste this line:

“/api/auth/login doesn’t set a cookie (or /api/auth/me is 401 with cookie). Mount session before routes; remove cookie.domain; set SameSite/secure per origin; client must use credentials:'include'. Serve SPA from Express in prod so it’s same-origin.`”