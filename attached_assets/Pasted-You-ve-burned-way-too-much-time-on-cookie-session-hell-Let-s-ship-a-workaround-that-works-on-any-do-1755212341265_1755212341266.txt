You’ve burned way too much time on cookie/session hell. Let’s ship a workaround that works on any domain: add stateless token auth as a fallback (keep your session cookie for later), and have the client use a Bearer token. This bypasses all the browser cookie quirks, redirects, and domain issues. Do the steps below exactly; then run the proof commands. If these pass, users can log in and play on lawduel.net immediately.

Do this now (exact patches)
1) Install a tiny token lib
npm i jsonwebtoken

2) Server: issue + verify tokens (keep your existing session code; we’ll support both)

server/token.ts

import jwt from "jsonwebtoken";

const ACCESS_TTL = "7d"; // adjust as you like
const SECRET = process.env.JWT_SECRET || "change-me-now";

export function signAccessToken(user: { id: string; username: string }) {
  return jwt.sign({ sub: user.id, username: user.username }, SECRET, { expiresIn: ACCESS_TTL });
}

export function verifyAccessToken(authHeader?: string) {
  if (!authHeader || !authHeader.toLowerCase().startsWith("bearer ")) return null;
  const token = authHeader.slice(7).trim();
  try {
    const payload = jwt.verify(token, SECRET) as { sub: string; username?: string; exp: number };
    return payload;
  } catch {
    return null;
  }
}


server/auth.ts (augment your existing routes)

import { Router } from "express";
import bcrypt from "bcrypt";
import { getUserByUsername, getUserById } from "./db.js";
import { signAccessToken, verifyAccessToken } from "./token.js";

const r = Router();

// LOGIN — return JSON with token *and* set session (dual support)
r.post("/login", async (req, res, next) => {
  const { username, password } = req.body || {};
  const u = await getUserByUsername(username);
  if (!u || !(await bcrypt.compare(password, u.passwordHash))) {
    return res.status(401).json({ ok:false, error:"Invalid credentials" });
  }

  // keep session path (cookie) for users whose browsers allow it
  req.session.regenerate(err => {
    if (err) return next(err);
    req.session.user = { id: u.id, username: u.username };
    req.session.save(err2 => {
      if (err2) return next(err2);
      const token = signAccessToken({ id: u.id, username: u.username });
      res.json({ ok:true, user: req.session.user, token });
    });
  });
});

// ME — accept either cookie *or* Bearer token
r.get("/me", async (req, res) => {
  if (req.session?.user) {
    return res.json({ ok:true, user: req.session.user, mode:"session" });
  }
  const payload = verifyAccessToken(req.headers.authorization);
  if (payload) {
    const u = await getUserById(payload.sub);
    if (u) return res.json({ ok:true, user:{ id:u.id, username:u.username }, mode:"token" });
  }
  return res.status(401).json({ ok:false });
});

r.post("/logout", (req, res) => {
  req.session.destroy(() => {
    res.clearCookie("sid", { path:"/" });
    // client must also drop its token (see front-end patch)
    res.json({ ok:true });
  });
});

export default r;


Protect other APIs (optional but recommended): add tiny middleware that checks Authorization first, then cookie:

// server/requireAuth.ts
import { verifyAccessToken } from "./token.js";
export function requireAuth(req, res, next) {
  if (req.session?.user) return next();
  const payload = verifyAccessToken(req.headers.authorization);
  if (payload) { req.userId = payload.sub; return next(); }
  return res.status(401).json({ ok:false, error:"auth required" });
}


Use it on protected routes:

app.use("/api/duel", requireAuth, duelRouter);

3) Client: store token and send it on every call

Never rely solely on cookies. Use Bearer.

client/src/authToken.ts

let memToken: string | null = null;
export function setToken(t: string | null) {
  memToken = t;
  if (t) localStorage.setItem("ld_token", t); else localStorage.removeItem("ld_token");
}
export function getToken() {
  return memToken ?? localStorage.getItem("ld_token");
}


client/src/api.ts

import { getToken } from "./authToken";
export async function api(path: string, opts: RequestInit = {}) {
  const t = getToken();
  const headers = { "Content-Type":"application/json", ...(opts.headers||{}) } as Record<string,string>;
  if (t) headers["Authorization"] = `Bearer ${t}`;
  return fetch(`/api${path}`, { ...opts, credentials: "include", headers });
}


Login handler (hard navigate on success):

const res = await api("/auth/login", {
  method: "POST",
  body: JSON.stringify({ username, password })
});
if (res.ok) {
  const data = await res.json();
  if (data.token) setToken(data.token);
  window.location.assign("/play");
} else {
  setError("Invalid username or password");
}


On load (bootstrap):

useEffect(() => {
  api("/auth/me").then(async r => {
    if (r.ok) {
      window.history.replaceState(null, "", "/play");
    } else {
      // stay on landing/login
    }
  });
}, []);


Logout:

await api("/auth/logout", { method:"POST" });
setToken(null);
window.location.assign("/");